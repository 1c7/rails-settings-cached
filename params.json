{
  "name": "rails-settings-cached",
  "tagline": "This is imporved from rails-settings, added caching for all settings",
  "body": "# Rails Settings Cached\r\n\r\nThis is improved from [rails-settings](https://github.com/ledermann/rails-settings),\r\nadded caching for all settings. Settings is a plugin that makes managing a table of\r\nglobal key, value pairs easy. Think of it like a global Hash stored in your database,\r\nthat uses simple ActiveRecord like methods for manipulation. Keep track of any global\r\nsetting that you dont want to hard code into your rails app. You can store any kind\r\nof object. Strings, numbers, arrays, or any object.\r\n\r\n## Status\r\n\r\n[![Gem Version](https://badge.fury.io/rb/rails-settings-cached.svg)](https://rubygems.org/gems/rails-settings-cached) [![CI Status](https://travis-ci.org/huacnlee/rails-settings-cached.svg)](http://travis-ci.org/huacnlee/rails-settings-cached) [![Code Climate](https://codeclimate.com/github/huacnlee/rails-settings-cached/badges/gpa.svg)](https://codeclimate.com/github/huacnlee/rails-settings-cached) [![codecov.io](https://codecov.io/github/huacnlee/rails-settings-cached/coverage.svg?branch=master)](https://codecov.io/github/huacnlee/rails-settings-cached?branch=master)\r\n\r\n## Setup\r\n\r\nEdit your Gemfile:\r\n\r\n```ruby\r\ngem \"rails-settings-cached\"\r\n```\r\n\r\nGenerate your settings:\r\n\r\n```bash\r\n$ rails g settings:install\r\n```\r\n\r\nIf you want custom model name:\r\n\r\n```bash\r\n$ rails g settings:install SiteConfig\r\n```\r\n\r\nNow just put that migration in the database with:\r\n\r\n```bash\r\nrake db:migrate\r\n```\r\n\r\n## Usage\r\n\r\nThe syntax is easy.  First, lets create some settings to keep track of:\r\n\r\n```ruby\r\nSetting.admin_password = 'supersecret'\r\nSetting.date_format    = '%m %d, %Y'\r\nSetting.cocktails      = ['Martini', 'Screwdriver', 'White Russian']\r\nSetting.foo            = 123\r\nSetting.credentials    = { :username => 'tom', :password => 'secret' }\r\n```\r\n\r\nNow lets read them back:\r\n\r\n```ruby\r\nSetting.foo            # returns 123\r\n```\r\n\r\nChanging an existing setting is the same as creating a new setting:\r\n\r\n```ruby\r\nSetting.foo = 'super duper bar'\r\n```\r\n\r\nDecide you dont want to track a particular setting anymore?\r\n\r\n```ruby\r\nSetting.destroy :foo\r\nSetting.foo            # returns nil\r\n```\r\n\r\nWant a list of all the settings?\r\n```ruby\r\nSetting.get_all\r\n```\r\n\r\nYou need name spaces and want a list of settings for a give name space? Just choose your prefered named space delimiter and use `Setting.get_all` (`Settings.all` for # Rails 3.x and 4.0.x) like this:\r\n\r\n```ruby\r\nSetting['preferences.color'] = :blue\r\nSetting['preferences.size'] = :large\r\nSetting['license.key'] = 'ABC-DEF'\r\n# Rails 4.1.x\r\nSetting.get_all('preferences.')\r\n# Rails 3.x and 4.0.x\r\nSetting.all('preferences.')\r\n# returns { 'preferences.color' => :blue, 'preferences.size' => :large }\r\n```\r\n\r\n## Extend a model\r\n\r\nSettings may be bound to any existing ActiveRecord object. Define this association like this:\r\nNotice! is not do caching in this version.\r\n\r\n```ruby\r\nclass User < ActiveRecord::Base\r\n  include RailsSettings::Extend\r\nend\r\n```\r\n\r\nThen you can set/get a setting for a given user instance just by doing this:\r\n\r\n```ruby\r\nuser = User.find(123)\r\nuser.settings.color = :red\r\nuser.settings.color # returns :red\r\nuser.settings.get_all\r\n# { \"color\" => :red }\r\n```\r\n\r\nIf you want to find users having or not having some settings, there are named scopes for this:\r\n\r\n```ruby\r\nUser.with_settings\r\n# => returns a scope of users having any setting\r\n\r\nUser.with_settings_for('color')\r\n# => returns a scope of users having a 'color' setting\r\n\r\nUser.without_settings\r\n# returns a scope of users having no setting at all (means user.settings.get_all == {})\r\n\r\nUser.without_settings('color')\r\n# returns a scope of users having no 'color' setting (means user.settings.color == nil)\r\n```\r\n\r\n## Default settings\r\n\r\nSometimes you may want define default settings.\r\n\r\nRailsSettings has generate a config YAML file in:\r\n\r\n```yml\r\n# config/app.yml\r\ndefaults: &defaults\r\n  github_token: \"123456\"\r\n  twitter_token: \"<%= ENV[\"TWITTER_TOKEN\"] %>\"\r\n  foo:\r\n    bar: \"Foo bar\"\r\n\r\ndevelopment:\r\n  <<: *defaults\r\n\r\ntest:\r\n  <<: *defaults\r\n\r\nproduction:\r\n  <<: *defaults\r\n```\r\n\r\nAnd you can use by `Setting` model:\r\n\r\n```\r\nSetting.github_token\r\n=> \"123456\"\r\nSetting.github_token = \"654321\"\r\n# Save into database.\r\nSetting.github_token\r\n# Read from databae / caching.\r\n=> \"654321\"\r\nSetting['foo.bar']\r\n=> 'Foo bar'\r\n```\r\n\r\nNOTE: YAML setting it also under the cache scope, when you restart Rails application, cache will expire,\r\n      so when you want change default config, you need restart Rails application server.\r\n\r\n### Caching flow:\r\n\r\n```\r\nSetting.foo -> Check Cache -> Exist - Write Cache -> Return\r\n                   |\r\n                Check DB -> Exist -> Write Cache -> Return\r\n                   |\r\n               Check Default -> Exist -> Write Cache -> Return\r\n                   |\r\n               Return nil\r\n```\r\n\r\n## Change cache key\r\n\r\n```ruby\r\nclass Setting < RailsSettings::Base\r\n  cache_prefix { 'you-prefix' }\r\n  ...\r\nend\r\n```\r\n\r\n-----\r\n\r\n## How to create a list, form to manage Settings?\r\n\r\nIf you want create an admin interface to editing the Settings, you can try methods in follow:\r\n\r\nconfig/routes.rb\r\n\r\n```rb\r\nnamespace :admin do\r\n  resources :settings\r\nend\r\n```\r\n\r\n\r\napp/controllers/admin/settings_controller.rb\r\n\r\n```rb\r\nmodule Admin\r\n  class SettingsController < ApplicationController\r\n    before_action :get_setting, only: [:edit, :update]\r\n\r\n    def index\r\n      @settings = Setting.get_all\r\n    end\r\n\r\n    def edit\r\n    end\r\n\r\n    def update\r\n      if @setting.value != params[:setting][:value]\r\n        @setting.value = params[:setting][:value]\r\n        @setting.save\r\n        redirect_to admin_settings_path, notice: 'Setting has updated.'\r\n      else\r\n        redirect_to admin_settings_path\r\n      end\r\n    end\r\n\r\n    def get_setting\r\n      @setting = Setting.find_by(var: params[:id]) || Setting.new(var: params[:id])\r\n    end\r\n  end\r\nend\r\n```\r\n\r\napp/views/admin/settings/index.html.erb\r\n\r\n```erb\r\n<table>\r\n  <tr>\r\n    <th>Key</th>\r\n    <th></th>\r\n  </tr>\r\n  <% @settings.each_key do |key| %>\r\n  <tr>\r\n    <td><%= key %></td>\r\n    <td><%= link_to 'edit', edit_admin_setting_path(key) %></td>\r\n  </tr>\r\n  <% end %>\r\n</table>\r\n```\r\n\r\napp/views/admin/settings/edit.html.erb\r\n\r\n```erb\r\n<%= form_for(@setting, url: admin_setting_path(@setting.var), method: 'patch') do |f| %>\r\n  <label><%= @setting.var %></label>\r\n  <%= f.text_area :value, rows: 10 %>\r\n  <%= f.submit %>\r\n<% end %>\r\n```\r\n\r\nAlso you may use [rails-settings-ui](https://github.com/accessd/rails-settings-ui) gem\r\nfor building ready to using interface with validations,\r\nor [activeadmin_settings_cached](https://github.com/artofhuman/activeadmin_settings_cached) gem if you use [activeadmin](https://github.com/activeadmin/activeadmin).\r\n\r\n## Use case:\r\n\r\n- [ruby-china/ruby-china](https://github.com/ruby-china/ruby-china)",
  "google": "UA-9745660-1",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}